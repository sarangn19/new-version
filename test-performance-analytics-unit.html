<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Analytics AI Unit Tests</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: #1F1F1F; color: white; font-family: system-ui; }
        .test-section { margin: 15px; padding: 15px; border: 1px solid #333; border-radius: 8px; }
        .success { border-color: #22c55e; background: rgba(34, 197, 94, 0.1); }
        .error { border-color: #ef4444; background: rgba(239, 68, 68, 0.1); }
        .test-result { margin: 8px 0; padding: 6px; border-radius: 4px; font-size: 13px; }
        .test-result.pass { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        .test-result.fail { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    </style>
</head>
<body>
    <div class="container mx-auto p-6">
        <h1 class="text-2xl font-bold mb-6 text-center">Performance Analytics AI Unit Tests</h1>
        
        <div class="text-center mb-6">
            <button id="run-tests" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                Run Unit Tests
            </button>
        </div>
        
        <div id="test-results"></div>
    </div>

    <!-- Load dependencies -->
    <script src="js/performance-optimizer.js"></script>
    <script src="js/performance-analyzer.js"></script>
    <script src="js/ai-service-manager.js"></script>
    <script src="js/performance-analytics-ai.js"></script>

    <script>
        class PerformanceAnalyticsUnitTests {
            constructor() {
                this.setupTests();
            }

            setupTests() {
                document.getElementById('run-tests').addEventListener('click', () => {
                    this.runAllTests();
                });
            }

            async runAllTests() {
                this.clearResults();
                
                // Test 1: Constructor and Configuration
                this.testConstructor();
                
                // Test 2: Data Gathering
                await this.testDataGathering();
                
                // Test 3: Performance Analysis
                await this.testPerformanceAnalysis();
                
                // Test 4: Weakness Identification
                await this.testWeaknessIdentification();
                
                // Test 5: Pattern Recognition
                this.testPatternRecognition();
                
                // Test 6: Learning Pattern Management
                this.testLearningPatterns();
                
                // Test 7: Task Generation
                await this.testTaskGeneration();
                
                // Test 8: Error Handling
                await this.testErrorHandling();
            }

            testConstructor() {
                const section = this.createTestSection('Constructor and Configuration');
                
                try {
                    const analytics = new PerformanceAnalyticsAI();
                    
                    this.addResult(section, 'Constructor executes without error', true);
                    
                    if (analytics.config && analytics.config.analysisMode === 'performance_analytics') {
                        this.addResult(section, 'Configuration loaded correctly', true);
                    } else {
                        this.addResult(section, 'Configuration not loaded', false);
                    }
                    
                    if (analytics.learningPatterns && analytics.learningPatterns.studyHabits instanceof Map) {
                        this.addResult(section, 'Learning patterns initialized', true);
                    } else {
                        this.addResult(section, 'Learning patterns not initialized', false);
                    }
                    
                    section.className = 'test-section success';
                } catch (error) {
                    this.addResult(section, `Constructor failed: ${error.message}`, false);
                    section.className = 'test-section error';
                }
            }

            async testDataGathering() {
                const section = this.createTestSection('Data Gathering');
                
                try {
                    const analytics = new PerformanceAnalyticsAI();
                    
                    const mockUserData = {
                        accuracy: 75,
                        studyTime: 4.5,
                        sessionsCompleted: 10
                    };
                    
                    const performanceData = await analytics.gatherPerformanceData(mockUserData);
                    
                    if (performanceData && performanceData.timestamp) {
                        this.addResult(section, 'Data gathering returns structured data', true);
                    } else {
                        this.addResult(section, 'Data gathering failed', false);
                    }
                    
                    if (performanceData.timeframe) {
                        this.addResult(section, 'Timeframe included in data', true);
                    }
                    
                    // Test data sufficiency check
                    const hasSufficient = analytics.hassufficientData(performanceData);
                    this.addResult(section, `Data sufficiency check: ${hasSufficient}`, true);
                    
                    section.className = 'test-section success';
                } catch (error) {
                    this.addResult(section, `Data gathering failed: ${error.message}`, false);
                    section.className = 'test-section error';
                }
            }

            async testPerformanceAnalysis() {
                const section = this.createTestSection('Performance Analysis');
                
                try {
                    const analytics = new PerformanceAnalyticsAI();
                    
                    const mockUserData = {
                        accuracy: 68,
                        consistency: 55,
                        studyTime: 4.2
                    };
                    
                    const analysis = await analytics.analyzePerformance(mockUserData);
                    
                    if (analysis) {
                        this.addResult(section, 'Performance analysis returns result', true);
                    } else {
                        this.addResult(section, 'Performance analysis failed', false);
                        return;
                    }
                    
                    if (analysis.overview) {
                        this.addResult(section, 'Analysis includes overview', true);
                    } else {
                        this.addResult(section, 'Analysis missing overview', false);
                    }
                    
                    if (analysis.combinedInsights) {
                        this.addResult(section, 'Analysis includes combined insights', true);
                    } else {
                        this.addResult(section, 'Analysis missing combined insights', false);
                    }
                    
                    if (analysis.analysisMethod) {
                        this.addResult(section, `Analysis method: ${analysis.analysisMethod}`, true);
                    }
                    
                    if (typeof analysis.confidence === 'number') {
                        this.addResult(section, `Confidence score: ${analysis.confidence}`, true);
                    }
                    
                    section.className = 'test-section success';
                } catch (error) {
                    this.addResult(section, `Performance analysis failed: ${error.message}`, false);
                    section.className = 'test-section error';
                }
            }

            async testWeaknessIdentification() {
                const section = this.createTestSection('Weakness Identification');
                
                try {
                    const analytics = new PerformanceAnalyticsAI();
                    
                    const mockPerformanceData = {
                        metrics: {
                            overallAccuracy: 55, // Low accuracy to trigger weakness
                            studyConsistency: 35, // Low consistency
                            focusQuality: 45 // Low focus
                        }
                    };
                    
                    const weaknesses = await analytics.identifyWeaknessPatterns(mockPerformanceData);
                    
                    if (Array.isArray(weaknesses)) {
                        this.addResult(section, 'Weakness identification returns array', true);
                    } else {
                        this.addResult(section, 'Weakness identification failed', false);
                        return;
                    }
                    
                    if (weaknesses.length > 0) {
                        this.addResult(section, `Identified ${weaknesses.length} weaknesses`, true);
                        
                        const firstWeakness = weaknesses[0];
                        if (firstWeakness.type && firstWeakness.severity && firstWeakness.area) {
                            this.addResult(section, 'Weaknesses have correct structure', true);
                        } else {
                            this.addResult(section, 'Weakness structure incomplete', false);
                        }
                        
                        // Check if weaknesses are ranked by severity
                        const severityOrder = { high: 3, medium: 2, low: 1 };
                        let properlyRanked = true;
                        for (let i = 1; i < weaknesses.length; i++) {
                            const prevSeverity = severityOrder[weaknesses[i-1].severity] || 1;
                            const currSeverity = severityOrder[weaknesses[i].severity] || 1;
                            if (prevSeverity < currSeverity) {
                                properlyRanked = false;
                                break;
                            }
                        }
                        
                        if (properlyRanked) {
                            this.addResult(section, 'Weaknesses properly ranked by severity', true);
                        } else {
                            this.addResult(section, 'Weakness ranking may be incorrect', false);
                        }
                    }
                    
                    section.className = 'test-section success';
                } catch (error) {
                    this.addResult(section, `Weakness identification failed: ${error.message}`, false);
                    section.className = 'test-section error';
                }
            }

            testPatternRecognition() {
                const section = this.createTestSection('Pattern Recognition');
                
                try {
                    const analytics = new PerformanceAnalyticsAI();
                    
                    const mockData = {
                        metrics: {
                            overallAccuracy: 65,
                            studyConsistency: 45,
                            consistencyScore: 55
                        }
                    };
                    
                    // Test accuracy pattern analysis
                    const accuracyPatterns = analytics.analyzeAccuracyPatterns(mockData);
                    if (Array.isArray(accuracyPatterns)) {
                        this.addResult(section, 'Accuracy pattern analysis works', true);
                        
                        if (accuracyPatterns.length > 0 && accuracyPatterns[0].type === 'accuracy') {
                            this.addResult(section, 'Accuracy patterns correctly identified', true);
                        }
                    } else {
                        this.addResult(section, 'Accuracy pattern analysis failed', false);
                    }
                    
                    // Test time-based pattern analysis
                    const timePatterns = analytics.analyzeTimeBasedPatterns(mockData);
                    if (Array.isArray(timePatterns)) {
                        this.addResult(section, 'Time-based pattern analysis works', true);
                    } else {
                        this.addResult(section, 'Time-based pattern analysis failed', false);
                    }
                    
                    // Test consistency pattern analysis
                    const consistencyPatterns = analytics.analyzeConsistencyPatterns(mockData);
                    if (Array.isArray(consistencyPatterns)) {
                        this.addResult(section, 'Consistency pattern analysis works', true);
                    } else {
                        this.addResult(section, 'Consistency pattern analysis failed', false);
                    }
                    
                    section.className = 'test-section success';
                } catch (error) {
                    this.addResult(section, `Pattern recognition failed: ${error.message}`, false);
                    section.className = 'test-section error';
                }
            }

            testLearningPatterns() {
                const section = this.createTestSection('Learning Pattern Management');
                
                try {
                    const analytics = new PerformanceAnalyticsAI();
                    
                    // Test pattern updates
                    const mockPerformanceData = {
                        metrics: {
                            studyConsistency: 75,
                            focusQuality: 80
                        },
                        trends: {
                            trends: {
                                accuracy: 1.2,
                                studyTime: 0.5
                            }
                        }
                    };
                    
                    const mockAnalysis = { confidence: 0.8 };
                    
                    analytics.updateLearningPatterns(mockPerformanceData, mockAnalysis);
                    this.addResult(section, 'Learning patterns updated without error', true);
                    
                    // Test pattern saving and loading
                    analytics.saveLearningPatterns();
                    this.addResult(section, 'Learning patterns saved', true);
                    
                    analytics.loadLearningPatterns();
                    this.addResult(section, 'Learning patterns loaded', true);
                    
                    // Check if patterns are stored correctly
                    if (analytics.learningPatterns.studyHabits.has('consistency')) {
                        this.addResult(section, 'Study habit patterns stored correctly', true);
                    }
                    
                    section.className = 'test-section success';
                } catch (error) {
                    this.addResult(section, `Learning pattern management failed: ${error.message}`, false);
                    section.className = 'test-section error';
                }
            }

            async testTaskGeneration() {
                const section = this.createTestSection('Task Generation');
                
                try {
                    const analytics = new PerformanceAnalyticsAI();
                    
                    const mockUserProfile = {
                        sessionHistory: [
                            { date: new Date().toISOString(), duration: 60, performance: { accuracy: 70 } }
                        ]
                    };
                    
                    const mockGoals = {
                        targetSubjects: ['History', 'Geography']
                    };
                    
                    // Test daily task generation
                    const dailyTasks = await analytics.generateDailyTasks(mockUserProfile, mockGoals);
                    
                    if (Array.isArray(dailyTasks)) {
                        this.addResult(section, 'Daily task generation returns array', true);
                    } else {
                        this.addResult(section, 'Daily task generation failed', false);
                        return;
                    }
                    
                    if (dailyTasks.length > 0) {
                        this.addResult(section, `Generated ${dailyTasks.length} daily tasks`, true);
                        
                        const firstTask = dailyTasks[0];
                        if (firstTask.id && firstTask.type && firstTask.title) {
                            this.addResult(section, 'Tasks have correct structure', true);
                        } else {
                            this.addResult(section, 'Task structure incomplete', false);
                        }
                    }
                    
                    // Test priority area identification
                    const recentData = await analytics.getRecentPerformanceData(mockUserProfile, 7);
                    const priorityAreas = await analytics.identifyPriorityAreas(recentData, mockGoals);
                    
                    if (Array.isArray(priorityAreas)) {
                        this.addResult(section, 'Priority area identification works', true);
                    } else {
                        this.addResult(section, 'Priority area identification failed', false);
                    }
                    
                    // Test task generation for specific areas
                    if (priorityAreas.length > 0) {
                        const areaTasks = await analytics.generateTasksForArea(priorityAreas[0], mockUserProfile, mockGoals);
                        if (Array.isArray(areaTasks)) {
                            this.addResult(section, 'Area-specific task generation works', true);
                        } else {
                            this.addResult(section, 'Area-specific task generation failed', false);
                        }
                    }
                    
                    section.className = 'test-section success';
                } catch (error) {
                    this.addResult(section, `Task generation failed: ${error.message}`, false);
                    section.className = 'test-section error';
                }
            }

            async testErrorHandling() {
                const section = this.createTestSection('Error Handling');
                
                try {
                    const analytics = new PerformanceAnalyticsAI();
                    
                    // Test with null data
                    const nullAnalysis = await analytics.analyzePerformance(null);
                    if (nullAnalysis && nullAnalysis.error) {
                        this.addResult(section, 'Null data handled gracefully', true);
                    } else {
                        this.addResult(section, 'Null data handling may be incomplete', false);
                    }
                    
                    // Test with invalid data
                    const invalidAnalysis = await analytics.analyzePerformance({ invalid: 'data' });
                    if (invalidAnalysis) {
                        this.addResult(section, 'Invalid data handled gracefully', true);
                    } else {
                        this.addResult(section, 'Invalid data handling failed', false);
                    }
                    
                    // Test insufficient data scenario
                    const insufficientData = { accuracy: 50 }; // Minimal data
                    const fallbackAnalysis = await analytics.analyzePerformance(insufficientData);
                    
                    if (fallbackAnalysis && fallbackAnalysis.analysisMethod === 'insufficient_data') {
                        this.addResult(section, 'Insufficient data fallback works', true);
                    } else if (fallbackAnalysis && fallbackAnalysis.analysisMethod === 'traditional') {
                        this.addResult(section, 'Traditional analysis fallback works', true);
                    } else {
                        this.addResult(section, 'Fallback analysis may not be working', false);
                    }
                    
                    // Test error fallback generation
                    const errorFallback = analytics.generateErrorFallback(new Error('Test error'));
                    if (errorFallback && errorFallback.error === true) {
                        this.addResult(section, 'Error fallback generation works', true);
                    } else {
                        this.addResult(section, 'Error fallback generation failed', false);
                    }
                    
                    section.className = 'test-section success';
                } catch (error) {
                    this.addResult(section, `Error handling test failed: ${error.message}`, false);
                    section.className = 'test-section error';
                }
            }

            // Utility methods
            createTestSection(title) {
                const section = document.createElement('div');
                section.className = 'test-section';
                section.innerHTML = `
                    <h3 class="text-lg font-semibold mb-3">${title}</h3>
                    <div class="results-container"></div>
                `;
                document.getElementById('test-results').appendChild(section);
                return section;
            }

            addResult(section, message, passed) {
                const container = section.querySelector('.results-container');
                const result = document.createElement('div');
                result.className = `test-result ${passed ? 'pass' : 'fail'}`;
                result.innerHTML = `${passed ? '✅' : '❌'} ${message}`;
                container.appendChild(result);
            }

            clearResults() {
                document.getElementById('test-results').innerHTML = '';
            }
        }

        // Initialize test suite
        document.addEventListener('DOMContentLoaded', () => {
            new PerformanceAnalyticsUnitTests();
        });
    </script>
</body>
</html>